(self.webpackChunkguzzle=self.webpackChunkguzzle||[]).push([[116],{3905:function(e,t,a){"use strict";a.d(t,{Zo:function(){return c},kt:function(){return p}});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var d=n.createContext({}),s=function(e){var t=n.useContext(d),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},c=function(e){var t=s(e.components);return n.createElement(d.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,l=e.originalType,d=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),m=s(a),p=i,u=m["".concat(d,".").concat(p)]||m[p]||h[p]||l;return a?n.createElement(u,r(r({ref:t},c),{},{components:a})):n.createElement(u,r({ref:t},c))}));function p(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=a.length,r=new Array(l);r[0]=m;var o={};for(var d in t)hasOwnProperty.call(t,d)&&(o[d]=t[d]);o.originalType=e,o.mdxType="string"==typeof e?e:i,r[1]=o;for(var s=2;s<l;s++)r[s]=a[s];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},370:function(e,t,a){"use strict";a.r(t),a.d(t,{frontMatter:function(){return o},metadata:function(){return d},toc:function(){return s},default:function(){return h}});var n=a(2122),i=a(9756),l=(a(7294),a(3905)),r=["components"],o={id:"derivation_strategies",title:"Schema Derivation Strategies"},d={unversionedId:"how_to_guides/ingest_data/derivation_strategies",id:"how_to_guides/ingest_data/derivation_strategies",isDocsHomePage:!1,title:"Schema Derivation Strategies",description:"* Guzzle provides five schema derivation strategies. Using these strategies Guzzle will validate the data type and will also create an effective schema based on that data will be written in the target and reject table. The schema derivation strategies include:",source:"@site/docs/how_to_guides/ingest_data/Derivation Strategy.md",sourceDirName:"how_to_guides/ingest_data",slug:"/how_to_guides/ingest_data/derivation_strategies",permalink:"/docs/how_to_guides/ingest_data/derivation_strategies",editUrl:"https://github.com/ja-guzzle/docs/blob/master/docs/how_to_guides/ingest_data/Derivation Strategy.md",version:"current",frontMatter:{id:"derivation_strategies",title:"Schema Derivation Strategies"},sidebar:"sideBar",previous:{title:"Pre-SQL and Post-SQL for Source and Target in Ingestion",permalink:"/docs/how_to_guides/ingest_data/pre-SQL_and_post-SQL_in_ingestion"},next:{title:"How overwrite and append operation works in Guzzle",permalink:"/docs/how_to_guides/ingest_data/overwrite_and_append_operatoins"}},s=[{value:"Source",id:"source",children:[{value:"Example",id:"example",children:[]}]},{value:"Inherit source data type and do not apply validation",id:"inherit-source-data-type-and-do-not-apply-validation",children:[{value:"Example",id:"example-1",children:[]}]},{value:"Target",id:"target",children:[{value:"Example",id:"example-2",children:[]}]},{value:"Inherit target data types and do not apply validation",id:"inherit-target-data-types-and-do-not-apply-validation",children:[{value:"Example",id:"example-3",children:[]}]},{value:"Do not inherit schema from source or target",id:"do-not-inherit-schema-from-source-or-target",children:[{value:"Example",id:"example-4",children:[]}]}],c={toc:s};function h(e){var t=e.components,a=(0,i.Z)(e,r);return(0,l.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Guzzle provides five schema derivation strategies. Using these strategies Guzzle will validate the data type and will also create an effective schema based on that data will be written in the target and reject table. The schema derivation strategies include:"),(0,l.kt)("ol",{parentName:"li"},(0,l.kt)("li",{parentName:"ol"},"Source"),(0,l.kt)("li",{parentName:"ol"},"Inherit source data type and do not apply validation"),(0,l.kt)("li",{parentName:"ol"},"Target"),(0,l.kt)("li",{parentName:"ol"},"Inherit target data type and do not apply validation"),(0,l.kt)("li",{parentName:"ol"},"Do not inherit schema from source or target"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"Users can select schema derivation strategy from ",(0,l.kt)("strong",{parentName:"p"},"Inherit columns and datatype")," property under ",(0,l.kt)("strong",{parentName:"p"},"Additional settings")," dropdown menu in the validation and transformation section.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"In this article, we will discuss these strategies with examples"))),(0,l.kt)("h2",{id:"source"},"Source"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"If schema derivation strategy is ",(0,l.kt)("strong",{parentName:"li"},"source")," then, columns and data types will be inherited from the source files/table and, validation of data types will be performed based on source data types."),(0,l.kt)("li",{parentName:"ul"},"If the user does not specify the column name in the transformation and validation section then validation for that column will be performed and if the user specifies the source's column name in the transformation and validation section then the validation will be performed based on validate data type checkbox."),(0,l.kt)("li",{parentName:"ul"},"Additionally, an effective schema will be created using ",(0,l.kt)("ol",{parentName:"li"},(0,l.kt)("li",{parentName:"ol"},"Source columns and their respective data types."),(0,l.kt)("li",{parentName:"ol"},"Columns and data types are specified in the ",(0,l.kt)("strong",{parentName:"li"},"validation and transformation")," section of the ingestion job."))),(0,l.kt)("li",{parentName:"ul"},"And this effective schema will be used to create a table if an auto-create table checkbox is checked in the target section and in the reject section.")),(0,l.kt)("h3",{id:"example"},"Example"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"In source, a datastore is a file and format is delimited, and the file pattern includes two files that are file1.csv and file2.csv. And infer schema checkbox is checked in the source section. In target, the datastore is the delta table and the auto-create table checkbox is checked and the name of table is ",(0,l.kt)("strong",{parentName:"p"},"demo_schema_derivation"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The source data are like this "))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"file1.csv\n\nid,name\n1001,n1\n1002,n2\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"file2.csv\n\nid,name\n1003,n3\nid_1004,n4\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"In the validation and transformation section, we have defined ")),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"A new column ",(0,l.kt)("strong",{parentName:"li"},"full_name")," is doing concatenation of ",(0,l.kt)("strong",{parentName:"li"},"name"),' column and "_new" string. Since the full_name column does not exist in the source data, and we have provided data type value in the validation and transformation section so, Guzzle will respect that data type value and take that data type for the defined column. If the user does not provide the value of the data type then Guzzle will take ',(0,l.kt)("strong",{parentName:"li"},"string")," as a data type value."),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("strong",{parentName:"li"},"name")," column but a validate data type checkbox is ",(0,l.kt)("strong",{parentName:"li"},"unchecked"),", and also we haven't defined any data type so, Guzzle will not validate this column's data and the data type for this column will be inherited from the source as the name column is present in the source.")),(0,l.kt)("a",{href:"https://guzzle.justanalytics.com/img/docs/how-to-guides/ingest_data/schema_derivation_1.png",target:"_self"},(0,l.kt)("img",{width:"1000",src:"/img/docs/how-to-guides/ingest_data/schema_derivation_1.png"})),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"As shown in the figure that we have defined the data type for ",(0,l.kt)("strong",{parentName:"p"},"full_name")," column ",(0,l.kt)("strong",{parentName:"p"},"varchar(20)")," so, Guzzle will take this data type for the effective schema.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"While running the ingestion job Guzzle will create the target table using the below query and as schema derivation strategy is the ",(0,l.kt)("strong",{parentName:"p"},"source")," so, it will validate data of source column like datatype for id is an integer so, data which are successfully validated will be stored in the target table and those which are invalid will be stored in reject table/file."))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"CREATE TABLE IF NOT EXISTS demo_schema_derivation (`id` integer, `name` string, `full_name` varchar(20));\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"After a successful run of this job target table contains the following data: ")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"demo_schema_derivation\n\n| id   | name | full_name |\n| 1001 | n1   | n1_new    |\n| 1002 | n2   | n2_new    |\n| 1003 | n3   | n3_new    |\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Here, the data with ",(0,l.kt)("strong",{parentName:"li"},"id=id_1004")," is discarded because the data is in string and the data type of ",(0,l.kt)("strong",{parentName:"li"},"id")," column is an ",(0,l.kt)("strong",{parentName:"li"},"integer"),". So, Guzzle will store this data in the reject section.")),(0,l.kt)("h2",{id:"inherit-source-data-type-and-do-not-apply-validation"},"Inherit source data type and do not apply validation"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"If the schema derivation strategy is ",(0,l.kt)("strong",{parentName:"li"},"Inherit source data type and do not apply validation")," then, columns and data types will be inherited from the source files/table, but the validation of data types will not be performed automatically. This will be based on the validation and transformation section."),(0,l.kt)("li",{parentName:"ul"},"If the user does not specify the column name in the transformation and validation section then validation for that column will not be performed and if the user specifies the source's column name in the transformation and validation section then the validation will be performed based on validate data type checkbox."),(0,l.kt)("li",{parentName:"ul"},"Additionally, an effective schema will be created using ",(0,l.kt)("ol",{parentName:"li"},(0,l.kt)("li",{parentName:"ol"},"Source columns and their respective data types."),(0,l.kt)("li",{parentName:"ol"},"Columns and data types are specified in the ",(0,l.kt)("strong",{parentName:"li"},"validation and transformation")," section of the ingestion job."))),(0,l.kt)("li",{parentName:"ul"},"And this effective schema will be used to create a table if an auto-create table checkbox is checked in the target section and in the reject section.")),(0,l.kt)("h3",{id:"example-1"},"Example"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"In source, a datastore is a file and format is delimited, and the file pattern includes two files that are file1.csv and file2.csv. And infer schema checkbox is checked in the source section. In target, the datastore is the delta table and the auto-create table checkbox is checked and the name of the table is ",(0,l.kt)("strong",{parentName:"p"},"demo_schema_derivation"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The source data are like this "))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"file1.csv\n\nid,name\n1001,n1\n1002,n2\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"file2.csv\n\nid,name\n1003,n3\nid_1004,n4\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"In the validation and transformation section, we have defined ")),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"A new column ",(0,l.kt)("strong",{parentName:"li"},"full_name")," is doing concatenation of ",(0,l.kt)("strong",{parentName:"li"},"name"),' column and "_new" string. Since the full_name column does not exist in the source data, and we have provided data type value in the validation and transformation section so, Guzzle will respect that data type value and take that data type for the defined column. If the user does not provide the value of the data type then Guzzle will take ',(0,l.kt)("strong",{parentName:"li"},"string")," as a data type value."),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("strong",{parentName:"li"},"name")," column but a validate data type checkbox is ",(0,l.kt)("strong",{parentName:"li"},"unchecked"),", and also we haven't defined any data type so, Guzzle will not validate this column's data and the data type for this column will be inherited from the source as the name column is present in the source.")),(0,l.kt)("a",{href:"https://guzzle.justanalytics.com/img/docs/how-to-guides/ingest_data/schema_derivation_2.png",target:"_self"},(0,l.kt)("img",{width:"1000",src:"/img/docs/how-to-guides/ingest_data/schema_derivation_2.png"})),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"As shown in the figure that we have defined the data type for ",(0,l.kt)("strong",{parentName:"p"},"full_name")," column ",(0,l.kt)("strong",{parentName:"p"},"varchar(20)")," so, Guzzle will take this data type for the effective schema.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"While running the ingestion job Guzzle will create the target table using the below query and as schema derivation strategy is the ",(0,l.kt)("strong",{parentName:"p"},"Inherit source data type and do not apply validation")," so, it will not do direct validation of the source column's data. So, Guzzle will take the help of the validation and transformation section on whether to validate or not.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"If the user wants to validate the data of the id column then the user has to define the id column in the transformation and validation section with the checked validate data type checkbox.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"And the data that are successfully validated will be stored in the target table and those which are invalid will be stored in the reject table/file."))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"CREATE TABLE IF NOT EXISTS demo_schema_derivation (`id` integer, `name` string, `full_name` varchar(20));\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"After a successful run of this job target table contains the following data: ")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"demo_schema_derivation\n\n| id      | name | full_name |\n| 1001    | n1   | n1_new    |\n| 1002    | n2   | n2_new    |\n| 1003    | n3   | n3_new    |\n|         | n4   | n4_new    |\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Here, ",(0,l.kt)("strong",{parentName:"li"},"id")," column is not defined in the validation and transformation section so, Guzzle will not validate the data. So, the data with ",(0,l.kt)("strong",{parentName:"li"},"id=id_1004")," is not discarded, and this data is stored in the target table with id value NULL as shown in the above table.")),(0,l.kt)("h2",{id:"target"},"Target"),(0,l.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,l.kt)("div",{parentName:"div",className:"admonition-heading"},(0,l.kt)("h5",{parentName:"div"},(0,l.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,l.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,l.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,l.kt)("div",{parentName:"div",className:"admonition-content"},(0,l.kt)("p",{parentName:"div"},"If schema derivation strategy is ",(0,l.kt)("strong",{parentName:"p"},"target")," then ",(0,l.kt)("strong",{parentName:"p"},"auto-create table")," checkbox for target section must be ",(0,l.kt)("strong",{parentName:"p"},"unchecked"),", and target table will be there in the database."))),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"If schema derivation strategy is ",(0,l.kt)("strong",{parentName:"li"},"target")," then, columns and data types will be inherited from the target files/table and, validation of data types will be performed based on target data types."),(0,l.kt)("li",{parentName:"ul"},"If the user does not specify the column name in the transformation and validation section then validation for that column will be performed and if the user specifies the target's column name in the transformation and validation section then the validation will be performed based on validate data type checkbox."),(0,l.kt)("li",{parentName:"ul"},"Additionally, an effective schema will be created using",(0,l.kt)("ol",{parentName:"li"},(0,l.kt)("li",{parentName:"ol"},"Target columns and their respective data types."),(0,l.kt)("li",{parentName:"ol"},"Columns and data types are specified in the ",(0,l.kt)("strong",{parentName:"li"},"validation and transformation")," section of the ingestion job."))),(0,l.kt)("li",{parentName:"ul"},"And this effective schema will be used to create a table if an auto-create table checkbox is checked in the reject section.")),(0,l.kt)("h3",{id:"example-2"},"Example"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"In source, a datastore is a file and format is delimited, and the file pattern includes two files that are file1.csv and file2.csv. And infer schema checkbox is checked in the source section. In target, the datastore is the delta table and the name of the table is ",(0,l.kt)("strong",{parentName:"p"},"demo_schema_derivation"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The source data are like this "))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"file1.csv\n\nid,name\n1001,n1\n1002,n2\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"file2.csv\n\nid,name\n1003,n3\nid_1004,n4\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The target table data is")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"demo_schema_derivation\n\n| id      | name |\n| 1010    | n10  |\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"In the validation and transformation section, we have defined ")),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"A new column ",(0,l.kt)("strong",{parentName:"li"},"full_name")," is doing concatenation of ",(0,l.kt)("strong",{parentName:"li"},"name"),' column and "_new" string. Since the full_name column does not exist in the target table, and we have provided data type value in the validation and transformation section so, Guzzle will respect that data type value and take that data type for the defined column. If the user does not provide the value of the data type then Guzzle will take ',(0,l.kt)("strong",{parentName:"li"},"string")," as a data type value."),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("strong",{parentName:"li"},"name")," column but a validate data type checkbox is ",(0,l.kt)("strong",{parentName:"li"},"unchecked"),", and also we haven't defined any data type so, Guzzle will not validate this column's data and the data type for this column will be inherited from the target as the name column is present in the target.")),(0,l.kt)("a",{href:"https://guzzle.justanalytics.com/img/docs/how-to-guides/ingest_data/schema_derivation_3.png",target:"_self"},(0,l.kt)("img",{width:"1000",src:"/img/docs/how-to-guides/ingest_data/schema_derivation_3.png"})),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"As shown in the figure that we have defined the data type for ",(0,l.kt)("strong",{parentName:"p"},"full_name")," column ",(0,l.kt)("strong",{parentName:"p"},"varchar(20)")," so, Guzzle will take this data type for the effective schema but as the target table does not have the ",(0,l.kt)("strong",{parentName:"p"},"full_name")," column, the data for this column will be ignored.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"While running the ingestion job, as schema derivation strategy is the ",(0,l.kt)("strong",{parentName:"p"},"target"),", Guzzle will validate the data of source column with target data type like datatype for id is an integer so, data which are successfully validated will be stored in the target table and those which are invalid will be stored in reject table/file.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"After a successful run of this job target table contains the following data: "))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"demo_schema_derivation\n\n| id   | name |\n| 1001 | n1   |\n| 1002 | n2   |\n| 1003 | n3   |\n| 1010 | n10  |\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Here, the data with ",(0,l.kt)("strong",{parentName:"li"},"id=id_1004")," is discarded because the data is in string and the data type of ",(0,l.kt)("strong",{parentName:"li"},"id")," column in target table is an ",(0,l.kt)("strong",{parentName:"li"},"integer"),". So, Guzzle will store this data in the reject section.")),(0,l.kt)("h2",{id:"inherit-target-data-types-and-do-not-apply-validation"},"Inherit target data types and do not apply validation"),(0,l.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,l.kt)("div",{parentName:"div",className:"admonition-heading"},(0,l.kt)("h5",{parentName:"div"},(0,l.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,l.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,l.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,l.kt)("div",{parentName:"div",className:"admonition-content"},(0,l.kt)("p",{parentName:"div"},"If schema derivation strategy is ",(0,l.kt)("strong",{parentName:"p"},"Inherit target data types and do not apply validation")," then ",(0,l.kt)("strong",{parentName:"p"},"auto-create table")," checkbox for target section must be ",(0,l.kt)("strong",{parentName:"p"},"unchecked"),", and target table will be there in the database."))),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"If the schema derivation strategy is ",(0,l.kt)("strong",{parentName:"li"},"Inherit target data types and do not apply validation")," then, columns and data types will be inherited from the target files/table and, the validation of data types will not be performed automatically. This will be based on the validation and transformation section."),(0,l.kt)("li",{parentName:"ul"},"If the user does not specify the column name in the transformation and validation section then validation for that column will not be performed and if the user specifies the target's column name in the transformation and validation section then the validation will be performed based on validate data type checkbox."),(0,l.kt)("li",{parentName:"ul"},"Additionally, an effective schema will be created using",(0,l.kt)("ol",{parentName:"li"},(0,l.kt)("li",{parentName:"ol"},"Target columns and their respective data types."),(0,l.kt)("li",{parentName:"ol"},"Columns and data types specified in the ",(0,l.kt)("strong",{parentName:"li"},"validation and transformation")," section of the ingestion job."))),(0,l.kt)("li",{parentName:"ul"},"And this effective schema will be used to create a table if an auto-create table checkbox is checked in the reject section.")),(0,l.kt)("h3",{id:"example-3"},"Example"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"In source, a datastore is a file and format is delimited, and the file pattern includes two files that are file1.csv and file2.csv. And infer schema checkbox is checked. In target, the datastore is the delta table and the name of the table is ",(0,l.kt)("strong",{parentName:"p"},"demo_schema_derivation"),".")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The source data are like this "))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"file1.csv\n\nid,name\n1001,n1\n1002,n2\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"file2.csv\n\nid,name\n1003,n3\nid_1004,n4\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The target table data is")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"demo_schema_derivation\n\n| id      | name |\n| 1010    | n10  |\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"In the validation and transformation section, we have defined ")),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"A new column ",(0,l.kt)("strong",{parentName:"li"},"full_name")," is doing concatenation of ",(0,l.kt)("strong",{parentName:"li"},"name"),' column and "_new" string. Since the full_name column does not exist in the target table, and we have provided data type value in the validation and transformation section so, Guzzle will respect that data type value and take that data type for the defined column. If the user does not provide the value of the data type then Guzzle will take ',(0,l.kt)("strong",{parentName:"li"},"string")," as a data type value."),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("strong",{parentName:"li"},"name")," column but a validate data type checkbox is ",(0,l.kt)("strong",{parentName:"li"},"unchecked"),", and also we haven't defined any data type so, Guzzle will not validate this column's data and the data type for this column will be inherited from the target as the name column is present in the target.")),(0,l.kt)("a",{href:"https://guzzle.justanalytics.com/img/docs/how-to-guides/ingest_data/schema_derivation_4.png",target:"_self"},(0,l.kt)("img",{width:"1000",src:"/img/docs/how-to-guides/ingest_data/schema_derivation_4.png"})),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"As shown in the figure that we have defined the data type for ",(0,l.kt)("strong",{parentName:"p"},"full_name")," column ",(0,l.kt)("strong",{parentName:"p"},"varchar(20)")," so, Guzzle will take this data type for the effective schema but as the target table does not have the ",(0,l.kt)("strong",{parentName:"p"},"full_name")," column, the data for this column will be ignored.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"While running the ingestion job, as schema derivation strategy is the ",(0,l.kt)("strong",{parentName:"p"},"Inherit target data types and do not apply validation"),", Guzzle will not do direct validation of the source column's data with the target column's data type. So, Guzzle will take the help of the validation and transformation section on whether to validate or not.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"And the data that are successfully validated will be stored in the target table and those which are invalid will be stored in the reject table/file.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"After a successful run of this job target table contains the following data: "))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"demo_schema_derivation\n\n| id   | name |\n| 1001 | n1   |\n| 1002 | n2   |\n| 1003 | n3   |\n|      | n4   |\n| 1010 | n10  |\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Here, id column is not defined in the validation and transformation section so, Guzzle will not validate the data for that column. So, the data with id=id_1004 is not discarded, and this data is stored in the target table with id value NULL as shown in the above table.")),(0,l.kt)("h2",{id:"do-not-inherit-schema-from-source-or-target"},"Do not inherit schema from source or target"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"If the schema derivation strategy is ",(0,l.kt)("strong",{parentName:"li"},"Do not inherit schema from source or target")," then, columns and data types will be inherited from the transformation and validation section and, the validation of data types will be performed based on the validate data type checkbox. If the checkbox is checked then validation of that column will be performed, if unchecked then validation will not be performed."),(0,l.kt)("li",{parentName:"ul"},"Additionally, an effective schema will be created using ",(0,l.kt)("ol",{parentName:"li"},(0,l.kt)("li",{parentName:"ol"},"columns and data types specified in the ",(0,l.kt)("strong",{parentName:"li"},"validation and transformation")," section of the ingestion job."))),(0,l.kt)("li",{parentName:"ul"},"And this effective schema will be used to create a table if an auto-create table checkbox is checked in the target section and in the reject section.")),(0,l.kt)("h3",{id:"example-4"},"Example"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"In source, a datastore is a file and format is delimited, and the file pattern includes two files that are file1.csv and file2.csv. And infer schema checkbox is checked. In target, the datastore is the delta table and the auto-create table checkbox is checked and the name of table is demo_schema_derivation.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"The source data are like this "))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"file1.csv\n\nid,name\n1001,n1\n1002,n2\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"file2.csv\n\nid,name\n1003,n3\nid_1004,n4\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"In the validation and transformation section, we have defined ")),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"A new column ",(0,l.kt)("strong",{parentName:"li"},"full_name")," is doing concatenation of ",(0,l.kt)("strong",{parentName:"li"},"name"),' column and "_new" string. Since the full_name column does not exist in the target table, and we have provided data type value in the validation and transformation section so, Guzzle will respect that data type value and take that data type for the defined column. If the user does not provide the value of the data type then Guzzle will take ',(0,l.kt)("strong",{parentName:"li"},"string")," as a data type value."),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("strong",{parentName:"li"},"name")," column but a validate data type checkbox is ",(0,l.kt)("strong",{parentName:"li"},"unchecked"),", and also we haven't defined any data type so, Guzzle will not validate this column's data and the data type for this column will be ",(0,l.kt)("strong",{parentName:"li"},"string")," as there is no data type defined."),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("strong",{parentName:"li"},"id")," column with data type value integer and validate data type checkbox is checked.")),(0,l.kt)("a",{href:"https://guzzle.justanalytics.com/img/docs/how-to-guides/ingest_data/schema_derivation_5.png",target:"_self"},(0,l.kt)("img",{width:"1000",src:"/img/docs/how-to-guides/ingest_data/schema_derivation_5.png"})),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"As shown in the figure, we have defined the data type for ",(0,l.kt)("strong",{parentName:"p"},"full_name")," column varchar(20), for ",(0,l.kt)("strong",{parentName:"p"},"id")," column is integer and for ",(0,l.kt)("strong",{parentName:"p"},"name")," column nothing so, Guzzle will take string data type and, Guzzle will take these columns and data type for the effective schema.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"While running the ingestion job Guzzle will create the target table using the below query, as the schema derivation strategy is the ",(0,l.kt)("strong",{parentName:"p"},"Do not inherit schema from source or target"),", it will take the help of the validation and transformation section whether to validate or not."))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"CREATE TABLE IF NOT EXISTS demo_schema_derivation (`id` integer, `name` string, `full_name` varchar(20));\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"And the data that are successfully validated will be stored in the target table and those which are invalid will be stored in the reject table/file.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"After a successful run of this job target table contains the following data: "))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"demo_schema_derivation\n\n| id   | name |\n| 1001 | n1   |\n| 1002 | n2   |\n| 1003 | n3   |\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Here, id column is defined in the validation and transformation section and validate data type checkbox is checked so, Guzzle will validate the data for that column. So, the data with ",(0,l.kt)("strong",{parentName:"li"},"id=id_1004")," is discarded, and this data is stored in the reject section.")))}h.isMDXComponent=!0}}]);